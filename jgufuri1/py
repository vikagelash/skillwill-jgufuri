import random
from abc import ABC, abstractmethod

class Mixin:
    _existing_codes = set()

    @staticmethod
    def generate_unique_code():
        while True:
            code = random.randint(1000, 1000000)
            if code not in Mixin._existing_codes:
                Mixin._existing_codes.add(code)
                return code


class Vehicle(ABC):
    def __init__(self, name: str, model: str):
        self._name = name
        self._model = model

    @abstractmethod
    def describe(self):
        pass

    @property
    def name(self):
        return self._name

    @property
    def model(self):
        return self._model


class Engine:
    def __init__(self, volume: float, h_p: int):
        self.__volume = volume
        self.__h_p = h_p

    @property
    def volume(self):
        return self.__volume

    @property
    def h_p(self):
        return self.__h_p

    def display_info(self):
        return f"{self.volume}L, {self.h_p} h.p."


class Car(Mixin, Vehicle):
    def __init__(self, name: str, model: str, engine: Engine, price: float, year_of_manufacture: int):
        super().__init__(name, model)
        self.__engine = engine
        self.__price = price
        self.__year_of_manufacture = year_of_manufacture
        self.__car_code = self.generate_unique_code()

    @property
    def engine(self):
        return self.__engine

    @property
    def price(self):
        return self.__price

    @property
    def car_code(self):
        return self.__car_code

    @property
    def year_of_manufacture(self):
        return self.__year_of_manufacture

    def describe(self):
        return f"{self.name} {self.model} with engine: {self.engine.display_info()} and costs ${self.price}."

    def __str__(self):
        return f"Car(Name: {self.name}, Model: {self.model}, Engine: {self.engine.display_info()}, Price: ${self.price}, Code: {self.car_code})"

    def apply_discount(self, discount_percentage: float):
        self.__price -= self.__price * (discount_percentage / 100)
        print(f"New price of {self.name} {self.model}: ${self.__price:.2f}")

    def get_car_age(self):
        current_year = 2024
        return current_year - self.year_of_manufacture

    def is_luxury(self):
        luxury_threshold = 50000
        return self.__price >= luxury_threshold

    def update_price(self, new_price: float):
        self.__price = new_price
        print(f"Price of {self.name} {self.model} updated to ${self.__price:.2f}")

    def compare_with_other_car(self, other_car: 'Car'):
        if self.engine.h_p > other_car.engine.h_p:
            print(f"{self.name} has more horsepower than {other_car.name}.")
        elif self.engine.h_p < other_car.engine.h_p:
            print(f"{self.name} has less horsepower than {other_car.name}.")
        else:
            print(f"{self.name} and {other_car.name} have the same horsepower.")

    def is_available_in_factory(self, factory):
        return self in factory.available_cars


class Factory:
    def __init__(self, available_cars: list[Car]):
        self.available_cars = available_cars

    def check_availability(self, model: str):
        for car in self.available_cars:
            if car.model == model:
                return car
        raise ValueError(f"The car model '{model}' is not available in the factory.")

    def dispatch_car(self, car: Car):
        self.available_cars.remove(car)
        print(f"Car {car.name} has been dispatched from the factory.")


class Customer(Mixin):
    def __init__(self, name: str, contact: str):
        self.name = name
        self.contact = contact
        self.customer_code = self.generate_unique_code()
        self.__purchases = []

    @property
    def purchases(self):
        return self.__purchases

    def request_car(self, factory: Factory, car_model: str):
        print(f"{self.name} (Code: {self.customer_code}) is requesting a {car_model}.")
        try:
            car = factory.check_availability(car_model)
            factory.dispatch_car(car)
            self.__purchases.append(car)
            print(f"Car {car.name} is now owned by {self.name}.")
            return car
        except ValueError as e:
            print(e)
            return None

    def get_details(self):
        return {
            "name": self.name,
            "contact": self.contact,
            "customer_code": self.customer_code,
            "purchases": [str(car) for car in self.purchases],
        }

    def describe(self):
        return f"Customer '{self.name}' has purchased {len(self.purchases)} car(s)."

    def __str__(self):
        return f"Customer(Name: {self.name}, Contact: {self.contact})"


if __name__ == "__main__":
    engine1 = Engine(2.0, 150)
    engine2 = Engine(3.5, 300)
    engine3 = Engine(1.8, 120)

    car1 = Car("Red Sedan", "Sedan", engine1, 25000, 2018)
    car2 = Car("Blue SUV", "SUV", engine2, 40000, 2020)
    car3 = Car("White Hatchback", "Hatchback", engine3, 18000, 2017)

    factory = Factory([car1, car2, car3])

    customer1 = Customer("Vika", "vika889@gmail.com")
    customer2 = Customer("Nika", "nika76@gmail.com")

    purchased_car = customer1.request_car(factory, "SUV")
    print(customer1.get_details())

    purchased_car = customer2.request_car(factory, "BMW")
    print(customer2.get_details())

    print("\nAll methods for Car class:")

    print("1. describe()")
    print(car1.describe())
    print("2. __str__()")
    print(str(car1))
    print("3. apply_discount(10)")
    car1.apply_discount(10)
    print("4. get_car_age()")
    print(car1.get_car_age())
    print("5. is_luxury()")
    print(car1.is_luxury())
    print("6. update_price(22000)")
    car1.update_price(22000)
    print("7. compare_with_other_car(car2)")
    car1.compare_with_other_car(car2)
    print("8. is_available_in_factory(factory)")
    print(car1.is_available_in_factory(factory))
